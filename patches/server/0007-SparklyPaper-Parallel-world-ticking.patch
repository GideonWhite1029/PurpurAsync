From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: GideonWhite1029 <gideonwhite1029@gmail.com>
Date: Mon, 27 May 2024 13:54:40 +0400
Subject: [PATCH] SparklyPaper: Parallel world ticking


diff --git a/build.gradle.kts b/build.gradle.kts
index 6f509740403efe392a80278777c1ee20810644a5..3df45986854deacf2c99854c4e018e304ae8e41a 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -4,6 +4,8 @@ import java.time.Instant
 plugins {
     java
     `maven-publish`
+    kotlin("jvm") version "1.9.20"
+    kotlin("plugin.serialization") version "1.9.20"
 }
 
 val log4jPlugins = sourceSets.create("log4jPlugins")
@@ -14,6 +16,9 @@ val alsoShade: Configuration by configurations.creating
 
 dependencies {
     implementation(project(":purpurasync-api")) // Pufferfish // Paper // Purpur // PurpurAsync
+    implementation(kotlin("reflect"))
+    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.3")
+    implementation("com.charleskorn.kaml:kaml:0.55.0")
     // Paper start
     implementation("org.jline:jline-terminal-jansi:3.21.0")
     implementation("net.minecrell:terminalconsoleappender:1.3.0")
diff --git a/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java b/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java
index 11b7f15755dde766140c29bedca456c80d53293f..0bddee29c63d63d3cfd02a299456430f4e4f3dd7 100644
--- a/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java
+++ b/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java
@@ -14,6 +14,7 @@ import java.util.concurrent.atomic.AtomicInteger;
 public class TickThread extends Thread {
 
     private static final Logger LOGGER = LoggerFactory.getLogger(TickThread.class);
+    public static final boolean HARD_THROW = !Boolean.getBoolean("sparklypaper.disableHardThrow"); // SparklyPaper - parallel world ticking - THIS SHOULD NOT BE DISABLED SINCE IT CAN CAUSE DATA CORRUPTION!!! Anyhow, for production servers, if you want to make a test run to see if the server could crash, you can test it with this disabled
 
     /**
      * @deprecated
@@ -22,52 +23,121 @@ public class TickThread extends Thread {
     public static void ensureTickThread(final String reason) {
         if (!isTickThread()) {
             LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            if (HARD_THROW)
+                throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final Level world, final BlockPos pos, final String reason) {
         if (!isTickThreadFor(world, pos)) {
-            LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason + " @ world " + world.getWorld().getName() + " blockPos: " + pos + " - " + getTickThreadInformation(world.getServer()), new Throwable());
+            if (HARD_THROW)
+                throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final Level world, final ChunkPos pos, final String reason) {
         if (!isTickThreadFor(world, pos)) {
-            LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason + " @ world " + world.getWorld().getName() + " chunkPos: " + pos + " - " + getTickThreadInformation(world.getServer()), new Throwable());
+            if (HARD_THROW)
+                throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final Level world, final int chunkX, final int chunkZ, final String reason) {
         if (!isTickThreadFor(world, chunkX, chunkZ)) {
-            LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason + " @ world " + world.getWorld().getName() + " chunkX: " + chunkX + " chunkZ: " + chunkZ + " - " + getTickThreadInformation(world.getServer()), new Throwable());
+            if (HARD_THROW)
+                throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final Entity entity, final String reason) {
         if (!isTickThreadFor(entity)) {
-            LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason + " @ entity " + entity.getStringUUID() + " - " + getTickThreadInformation(entity.getServer()), new Throwable());
+            if (HARD_THROW)
+                throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final Level world, final AABB aabb, final String reason) {
         if (!isTickThreadFor(world, aabb)) {
-            LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason + " @ world " + world.getWorld().getName() + " aabb: " + aabb + " - " + getTickThreadInformation(world.getServer()), new Throwable());
+            if (HARD_THROW)
+                throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final Level world, final double blockX, final double blockZ, final String reason) {
         if (!isTickThreadFor(world, blockX, blockZ)) {
-            LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            throw new IllegalStateException(reason);
+            LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason + " @ world " + world.getWorld().getName() + " blockX: " + blockX + " blockZ: " + blockZ + " - " + getTickThreadInformation(world.getServer()), new Throwable());
+            if (HARD_THROW)
+                throw new IllegalStateException(reason);
         }
     }
 
+    // SparklyPaper - parallel world ticking
+    // This is an additional method to check if the tick thread is bound to a specific world because, by default, Paper's isTickThread methods do not provide this information
+    // Because we only tick worlds in parallel (instead of regions), we can use this for our checks
+    public static void ensureTickThread(final net.minecraft.server.level.ServerLevel world, final String reason) {
+        if (!isTickThreadFor(world)) {
+            LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason + " @ world " + world.getWorld().getName() + " - " + getTickThreadInformation(world.getServer()), new Throwable());
+            if (HARD_THROW)
+                throw new IllegalStateException(reason);
+        }
+    }
+
+    // SparklyPaper - parallel world ticking
+    // This is an additional method to check if it is a tick thread but ONLY a tick thread
+    public static void ensureOnlyTickThread(final String reason) {
+        boolean isTickThread = isTickThread();
+        boolean isServerLevelTickThread = isServerLevelTickThread();
+        if (!isTickThread || isServerLevelTickThread) {
+            LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread ONLY tick thread check: " + reason, new Throwable());
+            if (HARD_THROW)
+                throw new IllegalStateException(reason);
+        }
+    }
+
+    // SparklyPaper - parallel world ticking
+    // This is an additional method to check if the tick thread is bound to a specific world or if it is an async thread.
+    public static void ensureTickThreadOrAsyncThread(final net.minecraft.server.level.ServerLevel world, final String reason) {
+        boolean isValidTickThread = isTickThreadFor(world);
+        boolean isAsyncThread = !isTickThread();
+        boolean isValid = isAsyncThread || isValidTickThread;
+        if (!isValid) {
+            LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread or async thread check: " + reason + " @ world " + world.getWorld().getName() + " - " + getTickThreadInformation(world.getServer()), new Throwable());
+            if (HARD_THROW)
+                throw new IllegalStateException(reason);
+        }
+    }
+
+    public static String getTickThreadInformation(net.minecraft.server.MinecraftServer minecraftServer) {
+        StringBuilder sb = new StringBuilder();
+        Thread currentThread = Thread.currentThread();
+        sb.append("Is tick thread? ");
+        sb.append(currentThread instanceof TickThread);
+        sb.append("; Is server level tick thread? ");
+        sb.append(currentThread instanceof ServerLevelTickThread);
+        if (currentThread instanceof ServerLevelTickThread serverLevelTickThread) {
+            sb.append("; Currently ticking level: ");
+            if (serverLevelTickThread.currentlyTickingServerLevel != null) {
+                sb.append(serverLevelTickThread.currentlyTickingServerLevel.getWorld().getName());
+            } else {
+                sb.append("null");
+            }
+        }
+        sb.append("; Is iterating over levels? ");
+        sb.append(minecraftServer.isIteratingOverLevels);
+        sb.append("; Are we going to hard throw? ");
+        sb.append(HARD_THROW);
+        return sb.toString();
+    }
+
+    public static boolean isServerLevelTickThread() {
+        return Thread.currentThread() instanceof ServerLevelTickThread;
+    }
+
     public final int id; /* We don't override getId as the spec requires that it be unique (with respect to all other threads) */
 
     private static final AtomicInteger ID_GENERATOR = new AtomicInteger();
@@ -98,42 +168,111 @@ public class TickThread extends Thread {
     }
 
     public static boolean isTickThreadFor(final Level world, final BlockPos pos) {
-        return isTickThread();
+        Thread currentThread = Thread.currentThread();
+
+        if (currentThread instanceof ServerLevelTickThread serverLevelTickThread) {
+            return serverLevelTickThread.currentlyTickingServerLevel == world;
+        } else return currentThread instanceof TickThread;
     }
 
     public static boolean isTickThreadFor(final Level world, final ChunkPos pos) {
-        return isTickThread();
+        Thread currentThread = Thread.currentThread();
+
+        if (currentThread instanceof ServerLevelTickThread serverLevelTickThread) {
+            return serverLevelTickThread.currentlyTickingServerLevel == world;
+        } else return currentThread instanceof TickThread;
     }
 
     public static boolean isTickThreadFor(final Level world, final Vec3 pos) {
-        return isTickThread();
+        Thread currentThread = Thread.currentThread();
+
+        if (currentThread instanceof ServerLevelTickThread serverLevelTickThread) {
+            return serverLevelTickThread.currentlyTickingServerLevel == world;
+        } else return currentThread instanceof TickThread;
     }
 
     public static boolean isTickThreadFor(final Level world, final int chunkX, final int chunkZ) {
-        return isTickThread();
+        Thread currentThread = Thread.currentThread();
+
+        if (currentThread instanceof ServerLevelTickThread serverLevelTickThread) {
+            return serverLevelTickThread.currentlyTickingServerLevel == world;
+        } else return currentThread instanceof TickThread;
     }
 
     public static boolean isTickThreadFor(final Level world, final AABB aabb) {
-        return isTickThread();
+        Thread currentThread = Thread.currentThread();
+
+        if (currentThread instanceof ServerLevelTickThread serverLevelTickThread) {
+            return serverLevelTickThread.currentlyTickingServerLevel == world;
+        } else return currentThread instanceof TickThread;
     }
 
     public static boolean isTickThreadFor(final Level world, final double blockX, final double blockZ) {
-        return isTickThread();
+        Thread currentThread = Thread.currentThread();
+
+        if (currentThread instanceof ServerLevelTickThread serverLevelTickThread) {
+            return serverLevelTickThread.currentlyTickingServerLevel == world;
+        } else return currentThread instanceof TickThread;
     }
 
     public static boolean isTickThreadFor(final Level world, final Vec3 position, final Vec3 deltaMovement, final int buffer) {
-        return isTickThread();
+        Thread currentThread = Thread.currentThread();
+
+        if (currentThread instanceof ServerLevelTickThread serverLevelTickThread) {
+            return serverLevelTickThread.currentlyTickingServerLevel == world;
+        } else return currentThread instanceof TickThread;
     }
 
     public static boolean isTickThreadFor(final Level world, final int fromChunkX, final int fromChunkZ, final int toChunkX, final int toChunkZ) {
-        return isTickThread();
+        Thread currentThread = Thread.currentThread();
+
+        if (currentThread instanceof ServerLevelTickThread serverLevelTickThread) {
+            return serverLevelTickThread.currentlyTickingServerLevel == world;
+        } else return currentThread instanceof TickThread;
     }
 
     public static boolean isTickThreadFor(final Level world, final int chunkX, final int chunkZ, final int radius) {
-        return isTickThread();
+        Thread currentThread = Thread.currentThread();
+
+        if (currentThread instanceof ServerLevelTickThread serverLevelTickThread) {
+            return serverLevelTickThread.currentlyTickingServerLevel == world;
+        } else return currentThread instanceof TickThread;
+    }
+
+    // SparklyPaper - parallel world ticking
+    // This is an additional method to check if the tick thread is bound to a specific world because, by default, Paper's isTickThread methods do not provide this information
+    // Because we only tick worlds in parallel (instead of regions), we can use this for our checks
+    public static boolean isTickThreadFor(final Level world) {
+        Thread currentThread = Thread.currentThread();
+
+        if (currentThread instanceof ServerLevelTickThread serverLevelTickThread) {
+            return serverLevelTickThread.currentlyTickingServerLevel == world;
+        } else return currentThread instanceof TickThread;
     }
 
     public static boolean isTickThreadFor(final Entity entity) {
-        return isTickThread();
+        if (entity == null) {
+            return true;
+        }
+
+        Thread currentThread = Thread.currentThread();
+
+        if (currentThread instanceof ServerLevelTickThread serverLevelTickThread) {
+            return serverLevelTickThread.currentlyTickingServerLevel == entity.level();
+        } else return currentThread instanceof TickThread;
+    }
+
+    // SparklyPaper start - parallel world ticking
+    public static class ServerLevelTickThread extends TickThread {
+        public ServerLevelTickThread(String name) {
+            super(name);
+        }
+
+        public ServerLevelTickThread(Runnable run, String name) {
+            super(run, name);
+        }
+
+        public net.minecraft.server.level.ServerLevel currentlyTickingServerLevel;
     }
+    // SparklyPaper end
 }
diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
index 58d3d1a47e9f2423c467bb329c2d5f4b58a8b5ef..0055e299220c8e0f4fa8ce13d61db36f3c697a10 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
@@ -1010,7 +1010,7 @@ public final class ChunkHolderManager {
         if (changedFullStatus.isEmpty()) {
             return;
         }
-        if (!TickThread.isTickThread()) {
+        if (!TickThread.isTickThreadFor(world)) { // SparklyPaper - parallel world ticking
             this.taskScheduler.scheduleChunkTask(() -> {
                 final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = ChunkHolderManager.this.pendingFullLoadUpdate;
                 for (int i = 0, len = changedFullStatus.size(); i < len; ++i) {
@@ -1037,7 +1037,7 @@ public final class ChunkHolderManager {
 
     // note: never call while inside the chunk system, this will absolutely break everything
     public void processUnloads() {
-        TickThread.ensureTickThread("Cannot unload chunks off-main");
+        TickThread.ensureTickThread(world, "Cannot unload chunks off-main"); // SparklyPaper - parallel world ticking
 
         if (BLOCK_TICKET_UPDATES.get() == Boolean.TRUE) {
             throw new IllegalStateException("Cannot unload chunks recursively");
@@ -1316,7 +1316,7 @@ public final class ChunkHolderManager {
 
         List<NewChunkHolder> changedFullStatus = null;
 
-        final boolean isTickThread = TickThread.isTickThread();
+        final boolean isTickThread = TickThread.isTickThreadFor(world);
 
         boolean ret = false;
         final boolean canProcessFullUpdates = processFullUpdates & isTickThread;
diff --git a/src/main/java/net/minecraft/core/dispenser/BoatDispenseItemBehavior.java b/src/main/java/net/minecraft/core/dispenser/BoatDispenseItemBehavior.java
index 6df0db8b4cdab23494ea34236949ece4989110a3..62943b954835fb30ce916c1a17fed39620a7882d 100644
--- a/src/main/java/net/minecraft/core/dispenser/BoatDispenseItemBehavior.java
+++ b/src/main/java/net/minecraft/core/dispenser/BoatDispenseItemBehavior.java
@@ -63,7 +63,7 @@ public class BoatDispenseItemBehavior extends DefaultDispenseItemBehavior {
         CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
 
         BlockDispenseEvent event = new BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector(d1, d2 + d4, d3));
-        if (!DispenserBlock.eventFired) {
+        if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
             worldserver.getCraftServer().getPluginManager().callEvent(event);
         }
 
diff --git a/src/main/java/net/minecraft/core/dispenser/DefaultDispenseItemBehavior.java b/src/main/java/net/minecraft/core/dispenser/DefaultDispenseItemBehavior.java
index 39c96f5db6e90a470404c6387fa0c1d5531822e5..08fba180a1d9c6e2b96b049122ed24cac62528fd 100644
--- a/src/main/java/net/minecraft/core/dispenser/DefaultDispenseItemBehavior.java
+++ b/src/main/java/net/minecraft/core/dispenser/DefaultDispenseItemBehavior.java
@@ -87,7 +87,7 @@ public class DefaultDispenseItemBehavior implements DispenseItemBehavior {
         CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack);
 
         BlockDispenseEvent event = new BlockDispenseEvent(block, craftItem.clone(), CraftVector.toBukkit(entityitem.getDeltaMovement()));
-        if (!DispenserBlock.eventFired) {
+        if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
             world.getCraftServer().getPluginManager().callEvent(event);
         }
 
diff --git a/src/main/java/net/minecraft/core/dispenser/DispenseItemBehavior.java b/src/main/java/net/minecraft/core/dispenser/DispenseItemBehavior.java
index bd07743817f2510c179614a6215434e7b333824a..684de7be27461fb1f9e976414505d0cbe9aca103 100644
--- a/src/main/java/net/minecraft/core/dispenser/DispenseItemBehavior.java
+++ b/src/main/java/net/minecraft/core/dispenser/DispenseItemBehavior.java
@@ -115,7 +115,7 @@ public interface DispenseItemBehavior {
                 CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
 
                 BlockDispenseEvent event = new BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector(0, 0, 0));
-                if (!DispenserBlock.eventFired) {
+                if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                     worldserver.getCraftServer().getPluginManager().callEvent(event);
                 }
 
@@ -174,7 +174,7 @@ public interface DispenseItemBehavior {
                 CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
 
                 BlockDispenseEvent event = new BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector(0, 0, 0));
-                if (!DispenserBlock.eventFired) {
+                if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                     worldserver.getCraftServer().getPluginManager().callEvent(event);
                 }
 
@@ -229,7 +229,7 @@ public interface DispenseItemBehavior {
                     CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
 
                     BlockDispenseArmorEvent event = new BlockDispenseArmorEvent(block, craftItem.clone(), (org.bukkit.craftbukkit.entity.CraftLivingEntity) list.get(0).getBukkitEntity());
-                    if (!DispenserBlock.eventFired) {
+                    if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                         world.getCraftServer().getPluginManager().callEvent(event);
                     }
 
@@ -285,7 +285,7 @@ public interface DispenseItemBehavior {
                 CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
 
                 BlockDispenseArmorEvent event = new BlockDispenseArmorEvent(block, craftItem.clone(), (org.bukkit.craftbukkit.entity.CraftLivingEntity) entityhorseabstract.getBukkitEntity());
-                if (!DispenserBlock.eventFired) {
+                if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                     world.getCraftServer().getPluginManager().callEvent(event);
                 }
 
@@ -359,7 +359,7 @@ public interface DispenseItemBehavior {
                 CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
 
                 BlockDispenseArmorEvent event = new BlockDispenseArmorEvent(block, craftItem.clone(), (org.bukkit.craftbukkit.entity.CraftLivingEntity) entityhorsechestedabstract.getBukkitEntity());
-                if (!DispenserBlock.eventFired) {
+                if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                     world.getCraftServer().getPluginManager().callEvent(event);
                 }
 
@@ -431,7 +431,7 @@ public interface DispenseItemBehavior {
                     CraftItemStack craftItem = CraftItemStack.asCraftMirror(stack.copyWithCount(1)); // Paper - single item in event
 
                     BlockDispenseEvent event = new BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector(x, y, z));
-                    if (!DispenserBlock.eventFired) {
+                    if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                         worldserver.getCraftServer().getPluginManager().callEvent(event);
                     }
 
@@ -496,7 +496,7 @@ public interface DispenseItemBehavior {
                         CraftItemStack craftItem = CraftItemStack.asCraftMirror(stack.copyWithCount(1)); // Paper - single item in event
 
                         BlockDispenseEvent event = new BlockDispenseEvent(bukkitBlock, craftItem.clone(), new org.bukkit.util.Vector(blockposition.getX(), blockposition.getY(), blockposition.getZ()));
-                        if (!DispenserBlock.eventFired) {
+                        if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                             worldserver.getCraftServer().getPluginManager().callEvent(event);
                         }
 
@@ -534,7 +534,7 @@ public interface DispenseItemBehavior {
                 CraftItemStack craftItem = CraftItemStack.asCraftMirror(stack); // Paper - ignore stack size on damageable items
 
                 BlockDispenseEvent event = new BlockDispenseEvent(bukkitBlock, craftItem.clone(), new org.bukkit.util.Vector(0, 0, 0));
-                if (!DispenserBlock.eventFired) {
+                if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                     worldserver.getCraftServer().getPluginManager().callEvent(event);
                 }
 
@@ -596,7 +596,7 @@ public interface DispenseItemBehavior {
                 CraftItemStack craftItem = CraftItemStack.asCraftMirror(stack.copyWithCount(1)); // Paper - single item in event
 
                 BlockDispenseEvent event = new BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector(0, 0, 0));
-                if (!DispenserBlock.eventFired) {
+                if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                     worldserver.getCraftServer().getPluginManager().callEvent(event);
                 }
 
@@ -625,8 +625,8 @@ public interface DispenseItemBehavior {
                 // CraftBukkit start
                 worldserver.captureTreeGeneration = false;
                 if (worldserver.capturedBlockStates.size() > 0) {
-                    TreeType treeType = SaplingBlock.treeType;
-                    SaplingBlock.treeType = null;
+                    TreeType treeType = SaplingBlock.treeTypeRT.get(); // SparklyPaper - parallel world ticking
+                    SaplingBlock.treeTypeRT.set(null); // SparklyPaper - parallel world ticking
                     Location location = CraftLocation.toBukkit(blockposition, worldserver.getWorld());
                     List<org.bukkit.block.BlockState> blocks = new java.util.ArrayList<>(worldserver.capturedBlockStates.values());
                     worldserver.capturedBlockStates.clear();
@@ -665,7 +665,7 @@ public interface DispenseItemBehavior {
                 CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
 
                 BlockDispenseEvent event = new BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector((double) blockposition.getX() + 0.5D, (double) blockposition.getY(), (double) blockposition.getZ() + 0.5D));
-                if (!DispenserBlock.eventFired) {
+                if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                    worldserver.getCraftServer().getPluginManager().callEvent(event);
                 }
 
@@ -722,7 +722,7 @@ public interface DispenseItemBehavior {
                 CraftItemStack craftItem = CraftItemStack.asCraftMirror(stack.copyWithCount(1)); // Paper - single item in event
 
                 BlockDispenseEvent event = new BlockDispenseEvent(bukkitBlock, craftItem.clone(), new org.bukkit.util.Vector(blockposition.getX(), blockposition.getY(), blockposition.getZ()));
-                if (!DispenserBlock.eventFired) {
+                if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                     worldserver.getCraftServer().getPluginManager().callEvent(event);
                 }
 
@@ -771,7 +771,7 @@ public interface DispenseItemBehavior {
                 CraftItemStack craftItem = CraftItemStack.asCraftMirror(stack.copyWithCount(1)); // Paper - single item in event
 
                 BlockDispenseEvent event = new BlockDispenseEvent(bukkitBlock, craftItem.clone(), new org.bukkit.util.Vector(blockposition.getX(), blockposition.getY(), blockposition.getZ()));
-                if (!DispenserBlock.eventFired) {
+                if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                     worldserver.getCraftServer().getPluginManager().callEvent(event);
                 }
 
@@ -833,7 +833,7 @@ public interface DispenseItemBehavior {
                 CraftItemStack craftItem = CraftItemStack.asCraftMirror(stack.copyWithCount(1)); // Paper - only single item in event
 
                 BlockDispenseEvent event = new BlockDispenseEvent(bukkitBlock, craftItem.clone(), new org.bukkit.util.Vector(blockposition.getX(), blockposition.getY(), blockposition.getZ()));
-                if (!DispenserBlock.eventFired) {
+                if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                     worldserver.getCraftServer().getPluginManager().callEvent(event);
                 }
 
@@ -915,7 +915,7 @@ public interface DispenseItemBehavior {
                     CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
 
                     BlockDispenseEvent event = new BlockDispenseArmorEvent(block, craftItem.clone(), (org.bukkit.craftbukkit.entity.CraftLivingEntity) list.get(0).getBukkitEntity());
-                    if (!DispenserBlock.eventFired) {
+                    if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                         world.getCraftServer().getPluginManager().callEvent(event);
                     }
 
diff --git a/src/main/java/net/minecraft/core/dispenser/ProjectileDispenseBehavior.java b/src/main/java/net/minecraft/core/dispenser/ProjectileDispenseBehavior.java
index e37d2d29f3ba67cfe28abe4847a3dca07121f0be..1635ae6106ee751704cbaaddcd7b3ad606fa6ae9 100644
--- a/src/main/java/net/minecraft/core/dispenser/ProjectileDispenseBehavior.java
+++ b/src/main/java/net/minecraft/core/dispenser/ProjectileDispenseBehavior.java
@@ -45,7 +45,7 @@ public class ProjectileDispenseBehavior extends DefaultDispenseItemBehavior {
         CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
 
         BlockDispenseEvent event = new BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector((double) enumdirection.getStepX(), (double) enumdirection.getStepY(), (double) enumdirection.getStepZ()));
-        if (!DispenserBlock.eventFired) {
+        if (!DispenserBlock.eventFired.get()) {
             worldserver.getCraftServer().getPluginManager().callEvent(event);
         }
 
diff --git a/src/main/java/net/minecraft/core/dispenser/ShearsDispenseItemBehavior.java b/src/main/java/net/minecraft/core/dispenser/ShearsDispenseItemBehavior.java
index 68632372c8704058f35f12e0ae6cdd98ebd55937..1c8d2c3a0fa7d61041f538d6e2450341353950ae 100644
--- a/src/main/java/net/minecraft/core/dispenser/ShearsDispenseItemBehavior.java
+++ b/src/main/java/net/minecraft/core/dispenser/ShearsDispenseItemBehavior.java
@@ -41,7 +41,7 @@ public class ShearsDispenseItemBehavior extends OptionalDispenseItemBehavior {
         CraftItemStack craftItem = CraftItemStack.asCraftMirror(stack); // Paper - ignore stack size on damageable items
 
         BlockDispenseEvent event = new BlockDispenseEvent(bukkitBlock, craftItem.clone(), new org.bukkit.util.Vector(0, 0, 0));
-        if (!DispenserBlock.eventFired) {
+        if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
             worldserver.getCraftServer().getPluginManager().callEvent(event);
         }
 
diff --git a/src/main/java/net/minecraft/core/dispenser/ShulkerBoxDispenseBehavior.java b/src/main/java/net/minecraft/core/dispenser/ShulkerBoxDispenseBehavior.java
index cb308808906a8cdb127df8284e106e00553473ca..323d41e2bed5e83a26dfe4c88dfce7ed87cdfb4c 100644
--- a/src/main/java/net/minecraft/core/dispenser/ShulkerBoxDispenseBehavior.java
+++ b/src/main/java/net/minecraft/core/dispenser/ShulkerBoxDispenseBehavior.java
@@ -37,7 +37,7 @@ public class ShulkerBoxDispenseBehavior extends OptionalDispenseItemBehavior {
             CraftItemStack craftItem = CraftItemStack.asCraftMirror(stack.copyWithCount(1)); // Paper - single item in event
 
             BlockDispenseEvent event = new BlockDispenseEvent(bukkitBlock, craftItem.clone(), new org.bukkit.util.Vector(blockposition.getX(), blockposition.getY(), blockposition.getZ()));
-            if (!DispenserBlock.eventFired) {
+            if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                 pointer.level().getCraftServer().getPluginManager().callEvent(event);
             }
 
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index bbaea9608aa7f0ef12d84119cf276295595036e5..b6595a0dd624c4c65425051182c491dbc091b986 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -326,6 +326,9 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public volatile boolean abnormalExit = false; // Paper
     public static final long SERVER_INIT = System.nanoTime(); // Paper - Lag compensation
     public gg.pufferfish.pufferfish.util.AsyncExecutor mobSpawnExecutor = new gg.pufferfish.pufferfish.util.AsyncExecutor("MobSpawning"); // Pufferfish - optimize mob spawning
+    // SparklyPaper - parallel world ticking
+    public java.util.concurrent.Semaphore serverLevelTickingSemaphore = null;
+    // SparklyPaper end
 
     public static <S extends MinecraftServer> S spin(Function<Thread, S> serverFactory) {
         AtomicReference<S> atomicreference = new AtomicReference();
@@ -1823,53 +1826,64 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
         this.isIteratingOverLevels = true; // Paper - Throw exception on world create while being ticked
         Iterator iterator = this.getAllLevels().iterator(); // Paper - Throw exception on world create while being ticked; move down
-        while (iterator.hasNext()) {
-            ServerLevel worldserver = (ServerLevel) iterator.next();
-            worldserver.hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - BlockPhysicsEvent
-            worldserver.hasEntityMoveEvent = io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - Add EntityMoveEvent
-            net.minecraft.world.level.block.entity.HopperBlockEntity.skipHopperEvents = worldserver.paperConfig().hopper.disableMoveEvent || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper - Perf: Optimize Hoppers
-            worldserver.updateLagCompensationTick(); // Paper - lag compensation
-            worldserver.hasRidableMoveEvent = org.purpurmc.purpur.event.entity.RidableMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Purpur
-
-            /*this.profiler.push(() -> { // Purpur
-                String s = String.valueOf(worldserver);
-
-                return s + " " + String.valueOf(worldserver.dimension().location());
-            });*/ // Purpur
-            /* Drop global time updates
-            if (this.tickCount % 20 == 0) {
-                //this.profiler.push("timeSync"); // Purpur
-                this.synchronizeTime(worldserver);
-                //this.profiler.pop(); // Purpur
+        // SparklyPaper start - parallel world ticking
+        java.util.ArrayDeque<java.util.concurrent.Future<ServerLevel>> tasks = new java.util.ArrayDeque<>();
+        try {
+            while (iterator.hasNext()) {
+                ServerLevel worldserver = (ServerLevel) iterator.next();
+                worldserver.updateLagCompensationTick(); // Paper - lag compensation
+                worldserver.hasRidableMoveEvent = org.purpurmc.purpur.event.entity.RidableMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Purpur
+                worldserver.hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
+                net.minecraft.world.level.block.entity.HopperBlockEntity.skipHopperEvents = worldserver.paperConfig().hopper.disableMoveEvent || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper
+                worldserver.hasEntityMoveEvent = io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
+
+                serverLevelTickingSemaphore.acquire();
+                tasks.add(
+                        worldserver.tickExecutor.submit(() -> {
+                            try {
+                                ca.spottedleaf.moonrise.common.util.TickThread.ServerLevelTickThread currentThread = (ca.spottedleaf.moonrise.common.util.TickThread.ServerLevelTickThread) Thread.currentThread();
+                                currentThread.currentlyTickingServerLevel = worldserver;
+
+                                worldserver.timings.doTick.startTiming(); // Spigot
+                                long i = Util.getNanos(); // SparklyPaper - track world's MSPT
+                                worldserver.tick(shouldKeepTicking);
+                                // SparklyPaper start - track world's MSPT
+                                long j = Util.getNanos() - i;
+
+                                // These are from the "tickServer" function
+                                worldserver.tickTimes5s.add(this.tickCount, j);
+                                worldserver.tickTimes10s.add(this.tickCount, j);
+                                worldserver.tickTimes60s.add(this.tickCount, j);
+                                // SparklyPaper end
+                                worldserver.timings.doTick.stopTiming(); // Spigot
+                            } catch (Throwable throwable) {
+                                // Spigot Start
+                                CrashReport crashreport;
+                                try {
+                                    crashreport = CrashReport.forThrowable(throwable, "Exception ticking world");
+                                } catch (Throwable t) {
+                                    if (throwable instanceof ThreadDeath) {
+                                        throw (ThreadDeath) throwable;
+                                    } // Paper
+                                    throw new RuntimeException("Error generating crash report", t);
+                                }
+                                // Spigot End
+                                worldserver.fillReportDetails(crashreport);
+                                throw new ReportedException(crashreport);
+                            } finally {
+                                serverLevelTickingSemaphore.release();
+                            }
+                        }, worldserver)
+                );
             }
-            // CraftBukkit end */
-
-            //this.profiler.push("tick"); // Purpur
-
-            try {
-                //worldserver.timings.doTick.startTiming(); // Spigot // Purpur
-                long i = Util.getNanos(); // SparklyPaper - track world's MSPT
-                worldserver.tick(shouldKeepTicking);
-                // SparklyPaper start - track world's MSPT
-                long j = Util.getNanos() - i;
-
-                // These are from the "tickServer" function
-                worldserver.tickTimes5s.add(this.tickCount, j);
-                worldserver.tickTimes10s.add(this.tickCount, j);
-                worldserver.tickTimes60s.add(this.tickCount, j);
-                // SparklyPaper end
-                //worldserver.timings.doTick.stopTiming(); // Spigot // Purpur
-            } catch (Throwable throwable) {
-                CrashReport crashreport = CrashReport.forThrowable(throwable, "Exception ticking world");
-
-                worldserver.fillReportDetails(crashreport);
-                throw new ReportedException(crashreport);
+            while (!tasks.isEmpty()) {
+                tasks.pop().get();
             }
 
-            //this.profiler.pop(); // Purpur
-            //this.profiler.pop(); // Purpur
-            worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
+        } catch (java.lang.InterruptedException | java.util.concurrent.ExecutionException e) {
+            throw new RuntimeException(e); // Propagate exception
         }
+        // SparklyPaper end
         this.isIteratingOverLevels = false; // Paper - Throw exception on world create while being ticked
 
         //this.profiler.popPush("connection"); // Purpur
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index 6e6f4dffceb0032153c5be119303c5809629cfcc..4b8011cf56d503bc5573399c0bdea7a903a311d1 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -252,6 +252,16 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         gg.pufferfish.pufferfish.PufferfishConfig.pufferfishFile = (java.io.File) options.valueOf("pufferfish-settings"); // Purpur
         gg.pufferfish.pufferfish.PufferfishConfig.load(); // Pufferfish
         gg.pufferfish.pufferfish.PufferfishCommand.init(); // Pufferfish
+        // SparklyPaper start
+        try {
+            net.sparklypower.sparklypaper.configs.SparklyPaperConfigUtils.INSTANCE.init((java.io.File) options.valueOf("sparklypaper-settings"));
+        } catch (Exception e) {
+            DedicatedServer.LOGGER.error("Unable to load server configuration", e);
+            return false;
+        }
+        serverLevelTickingSemaphore = new java.util.concurrent.Semaphore(net.sparklypower.sparklypaper.configs.SparklyPaperConfigUtils.INSTANCE.getConfig().getParallelWorldTicking().getThreads()); // SparklyPaper - parallel world ticking
+        DedicatedServer.LOGGER.info("Using " + serverLevelTickingSemaphore.availablePermits() + " permits for parallel world ticking"); // SparklyPaper - parallel world ticking
+        // SparklyPaper end
 
         this.setPvpAllowed(dedicatedserverproperties.pvp);
         this.setFlightAllowed(dedicatedserverproperties.allowFlight);
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index ebe872c4643038f0c99b289d4d5afdbedd76c6ef..5682a1334cedae18a024b6d60f0ba060235ee773 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -523,7 +523,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
                             this.level.tickChunk(chunk1, l);
                             // Paper start - rewrite chunk system
                             if ((++chunksTicked & 7L) == 0L) {
-                                ((ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer)this.level.getServer()).moonrise$executeMidTickTasks();
+                                // ((ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer)this.level.getServer()).moonrise$executeMidTickTasks();
                             }
                             // Paper end - rewrite chunk system
                         }
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 551f2b2fc8f8830f35bb88045b30bee20424d2b1..a92433cf9d96420a8ce88278f044526500ae3f11 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -224,6 +224,7 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
     private double preciseTime; // Purpur
     private boolean forceTime; // Purpur
     private final RandomSequences randomSequences;
+    public java.util.concurrent.ExecutorService tickExecutor; // SparklyPaper - parallel world ticking
 
     // CraftBukkit start
     public final LevelStorageSource.LevelStorageAccess convertable;
@@ -518,7 +519,7 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
         this.uuid = WorldUUID.getUUID(convertable_conversionsession.levelDirectory.path().toFile());
         // CraftBukkit end
         this.players = Lists.newArrayList();
-        this.entityTickList = new EntityTickList();
+        this.entityTickList = new EntityTickList(this);
         this.blockTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded, this.getProfilerSupplier());
         this.fluidTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded, this.getProfilerSupplier());
         this.pathTypesByPosCache = new PathTypeCache();
@@ -617,6 +618,7 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
         // Paper end - rewrite chunk system
         this.getCraftServer().addWorld(this.getWorld()); // CraftBukkit
         this.preciseTime = this.serverLevelData.getDayTime(); // Purpur
+        this.tickExecutor = java.util.concurrent.Executors.newSingleThreadExecutor(new net.sparklypower.sparklypaper.ServerLevelTickExecutorThreadFactory(getWorld().getName())); // SparklyPaper - parallel world ticking
     }
 
     // Paper start
@@ -1267,7 +1269,7 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
         }
         // Paper start - rewrite chunk system
         if ((++this.tickedBlocksOrFluids & 7L) != 0L) {
-            ((ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer)this.server).moonrise$executeMidTickTasks();
+            // ((ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer)this.server).moonrise$executeMidTickTasks();
         }
         // Paper end - rewrite chunk system
 
@@ -1281,7 +1283,7 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
         }
         // Paper start - rewrite chunk system
         if ((++this.tickedBlocksOrFluids & 7L) != 0L) {
-            ((ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer)this.server).moonrise$executeMidTickTasks();
+            // ((ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer)this.server).moonrise$executeMidTickTasks();
         }
         // Paper end - rewrite chunk system
 
@@ -1592,6 +1594,7 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
     }
 
     private void addPlayer(ServerPlayer player) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this, "Cannot add player off-main"); // SparklyPaper - parallel world ticking (additional concurrency issues logs)
         Entity entity = (Entity) this.getEntities().get(player.getUUID());
 
         if (entity != null) {
@@ -1605,7 +1608,7 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
 
     // CraftBukkit start
     private boolean addEntity(Entity entity, CreatureSpawnEvent.SpawnReason spawnReason) {
-        org.spigotmc.AsyncCatcher.catchOp("entity add"); // Spigot
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this, "Cannot add entity off-main"); // SparklyPaper - parallel world ticking (additional concurrency issues logs)
         entity.generation = false; // Paper - Don't fire sync event during generation; Reset flag if it was added during a ServerLevel generation process
         // Paper start - extra debug info
         if (entity.valid) {
@@ -2511,6 +2514,7 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
     public void close() throws IOException {
         super.close();
         // Paper - rewrite chunk system
+        tickExecutor.shutdown(); // SparklyPaper - parallel world ticking
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 4f72ce384f4c0dbae98effa89aed5c3bb802e635..7ba71483086d21e45be44e956987ace33c0859a4 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -336,6 +336,7 @@ public class ServerPlayer extends net.minecraft.world.entity.player.Player imple
         return this.viewDistanceHolder;
     }
     // Paper end - rewrite chunk system
+    public boolean hasTickedAtLeastOnceInNewWorld = false; // SparklyPaper - parallel world ticking (fixes bug in DreamResourceReset where the inventory is opened AFTER the player has changed worlds, if you click with the quick tp torch in a chest, because the inventory is opened AFTER the player has teleported)
 
     public ServerPlayer(MinecraftServer server, ServerLevel world, GameProfile profile, ClientInformation clientOptions) {
         super(world, world.getSharedSpawnPos(), world.getSharedSpawnAngle(), profile);
@@ -768,6 +769,7 @@ public class ServerPlayer extends net.minecraft.world.entity.player.Player imple
 
     @Override
     public void tick() {
+        hasTickedAtLeastOnceInNewWorld = true; // SparklyPaper - parallel world ticking (see: PARALLEL_NOTES.md - Opening an inventory after a world switch)
         // CraftBukkit start
         if (this.joining) {
             this.joining = false;
@@ -1387,6 +1389,7 @@ public class ServerPlayer extends net.minecraft.world.entity.player.Player imple
                 teleportTarget.postDimensionTransition().onTransition(this);
                 return this;
             } else {
+                ca.spottedleaf.moonrise.common.util.TickThread.ensureOnlyTickThread("Cannot change dimension of a player off-main, from world " + serverLevel().getWorld().getName() + " to world " + worldserver.getWorld().getName()); // SparklyPaper - parallel world ticking (additional concurrency issues logs)
                 // CraftBukkit start
                 /*
                 this.isChangingDimension = true;
@@ -1771,6 +1774,12 @@ public class ServerPlayer extends net.minecraft.world.entity.player.Player imple
                 return OptionalInt.empty();
             } else {
                 // CraftBukkit start
+                // SparklyPaper start - parallel world ticking (see: PARALLEL_NOTES.md - Opening an inventory after a world switch)
+                if (!hasTickedAtLeastOnceInNewWorld) {
+                    MinecraftServer.LOGGER.warn("Ignoring request to open container " + container + " because we haven't ticked in the current world yet!", new Throwable());
+                    return OptionalInt.empty();
+                }
+                // SparklyPaper end
                 this.containerMenu = container;
                 if (!this.isImmobile()) this.connection.send(new ClientboundOpenScreenPacket(container.containerId, container.getType(), Objects.requireNonNullElseGet(title, container::getTitle))); // Paper - Add titleOverride to InventoryOpenEvent
                 // CraftBukkit end
@@ -1834,6 +1843,11 @@ public class ServerPlayer extends net.minecraft.world.entity.player.Player imple
     }
     @Override
     public void closeContainer(org.bukkit.event.inventory.InventoryCloseEvent.Reason reason) {
+        // SparklyPaper start - parallel world ticking (debugging)
+        if (net.sparklypower.sparklypaper.configs.SparklyPaperConfigUtils.INSTANCE.getLogContainerCreationStacktraces()) {
+            MinecraftServer.LOGGER.warn("Closing " + this.getBukkitEntity().getName() + " inventory that was created at", this.containerMenu.containerCreationStacktrace);
+        }
+        // SparklyPaper end
         CraftEventFactory.handleInventoryCloseEvent(this, reason); // CraftBukkit
         // Paper end - Inventory close reason
         this.connection.send(new ClientboundContainerClosePacket(this.containerMenu.containerId));
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 0ea07da1b4bd420cd6765577b4719a2368b5740c..ff0f3bbde16390ec357b2a6850fd83769d9aa578 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -137,7 +137,7 @@ public abstract class PlayerList {
     private static final SimpleDateFormat BAN_DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd 'at' HH:mm:ss z");
     private final MinecraftServer server;
     public final List<ServerPlayer> players = new java.util.concurrent.CopyOnWriteArrayList(); // CraftBukkit - ArrayList -> CopyOnWriteArrayList: Iterator safety
-    private final Map<UUID, ServerPlayer> playersByUUID = Maps.newHashMap();
+    private final Map<UUID, ServerPlayer> playersByUUID = Maps.newHashMap(); // SparklyPaper - parallel world ticking (we don't need to replace the original map because we never iterate on top of this map)
     private final UserBanList bans;
     private final IpBanList ipBans;
     private final ServerOpList ops;
@@ -158,7 +158,7 @@ public abstract class PlayerList {
 
     // CraftBukkit start
     private CraftServer cserver;
-    private final Map<String,ServerPlayer> playersByName = new java.util.HashMap<>();
+    private final Map<String,ServerPlayer> playersByName = new java.util.HashMap<>(); // SparklyPaper - parallel world ticking (we don't need to replace the original map because we never iterate on top of this map)
     public @Nullable String collideRuleTeamName; // Paper - Configurable player collision
 
     public PlayerList(MinecraftServer server, LayeredRegistryAccess<RegistryLayer> registryManager, PlayerDataStorage saveHandler, int maxPlayers) {
@@ -182,6 +182,7 @@ public abstract class PlayerList {
     abstract public void loadAndSaveFiles(); // Paper - fix converting txt to json file; moved from DedicatedPlayerList constructor
 
     public void placeNewPlayer(Connection connection, ServerPlayer player, CommonListenerCookie clientData) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureOnlyTickThread("Cannot place new player off-main"); // SparklyPaper - parallel world ticking (additional concurrency issues logs)
         player.isRealPlayer = true; // Paper
         player.loginTime = System.currentTimeMillis(); // Paper - Replace OfflinePlayer#getLastPlayed
         GameProfile gameprofile = player.getGameProfile();
@@ -808,6 +809,13 @@ public abstract class PlayerList {
     }
 
     public ServerPlayer respawn(ServerPlayer entityplayer, boolean flag, Entity.RemovalReason entity_removalreason, RespawnReason reason, Location location) {
+        System.out.println("respawning player - current player container is " + entityplayer.containerMenu + " but their inventory is " + entityplayer.inventoryMenu);
+        // SparklyPaper - parallel world ticking (additional concurrency issues logs)
+        if (location != null)
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureOnlyTickThread("Cannot respawn player off-main, from world " + entityplayer.serverLevel().getWorld().getName() + " to world " + location.getWorld().getName());
+        else
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureOnlyTickThread("Cannot respawn player off-main, respawning in world " + entityplayer.serverLevel().getWorld().getName());
+        // SparklyPaper end
         entityplayer.stopRiding(); // CraftBukkit
         this.players.remove(entityplayer);
         this.playersByName.remove(entityplayer.getScoreboardName().toLowerCase(java.util.Locale.ROOT)); // Spigot
@@ -820,6 +828,7 @@ public abstract class PlayerList {
         ServerPlayer entityplayer1 = entityplayer;
         Level fromWorld = entityplayer.level();
         entityplayer.wonGame = false;
+        entityplayer.hasTickedAtLeastOnceInNewWorld = false; // SparklyPaper - parallel world ticking (see: PARALLEL_NOTES.md - Opening an inventory after a world switch)
         // CraftBukkit end
 
         entityplayer1.connection = entityplayer.connection;
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 7aadcaa1785c6560eb1ce2f1179225facca47d84..f60444c6e6578d9f1dfb269038e70ceb5c31c03d 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -883,7 +883,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     // CraftBukkit start
     public void postTick() {
         // No clean way to break out of ticking once the entity has been copied to a new world, so instead we move the portalling later in the tick cycle
-        if (!(this instanceof ServerPlayer) && this.isAlive()) { // Paper - don't attempt to teleport dead entities
+        if (false && !(this instanceof ServerPlayer) && this.isAlive()) { // Paper - don't attempt to teleport dead entities // SparklyPaper - parallel world ticking (see issue #9, this is executed in the server level tick for non-player entities)
             this.handlePortal();
         }
     }
@@ -4058,6 +4058,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
             this.teleportPassengers();
             this.setYHeadRot(yaw);
         } else {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(world, "Cannot teleport entity to another world off-main, from world " + level.getWorld().getName() + " to world " + world.getWorld().getName()); // SparklyPaper - parallel world ticking (additional concurrency issues logs)
             this.unRide();
             Entity entity = this.getType().create(world);
 
diff --git a/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java b/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
index ecfa807e78c16a24099d40becd0c7916f239aed1..45622fbad28fd12b54853b1e9e6cae55865d500e 100644
--- a/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
+++ b/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
@@ -103,8 +103,14 @@ public abstract class AbstractContainerMenu {
         this.title = title;
     }
     // CraftBukkit end
+    public Throwable containerCreationStacktrace; // SparklyPaper - parallel world ticking (debugging)
 
     protected AbstractContainerMenu(@Nullable MenuType<?> type, int syncId) {
+        // SparklyPaper - parallel world ticking (debugging)
+        if (net.sparklypower.sparklypaper.configs.SparklyPaperConfigUtils.INSTANCE.getLogContainerCreationStacktraces()) {
+            this.containerCreationStacktrace = new Throwable();
+        }
+        // SparklyPaper end
         this.carried = ItemStack.EMPTY;
         this.remoteSlots = NonNullList.create();
         this.remoteDataSlots = new IntArrayList();
diff --git a/src/main/java/net/minecraft/world/item/ArmorItem.java b/src/main/java/net/minecraft/world/item/ArmorItem.java
index d05b1e129eee07434d162e1b949fd5633418ef66..477915f548345fc5ee4991f4366ac2d94a26723c 100644
--- a/src/main/java/net/minecraft/world/item/ArmorItem.java
+++ b/src/main/java/net/minecraft/world/item/ArmorItem.java
@@ -68,7 +68,7 @@ public class ArmorItem extends Item implements Equipable {
             CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
 
             BlockDispenseArmorEvent event = new BlockDispenseArmorEvent(block, craftItem.clone(), (org.bukkit.craftbukkit.entity.CraftLivingEntity) entityliving.getBukkitEntity());
-            if (!DispenserBlock.eventFired) {
+            if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                 world.getCraftServer().getPluginManager().callEvent(event);
             }
 
diff --git a/src/main/java/net/minecraft/world/item/ItemStack.java b/src/main/java/net/minecraft/world/item/ItemStack.java
index 9d9af312037c96c7773a456e37e6425f7004e73a..37704b8b546496fb6c7dbceec62ce6a958f4404e 100644
--- a/src/main/java/net/minecraft/world/item/ItemStack.java
+++ b/src/main/java/net/minecraft/world/item/ItemStack.java
@@ -442,8 +442,8 @@ public final class ItemStack implements DataComponentHolder {
             if (enuminteractionresult.consumesAction() && world.captureTreeGeneration && world.capturedBlockStates.size() > 0) {
                 world.captureTreeGeneration = false;
                 Location location = CraftLocation.toBukkit(blockposition, world.getWorld());
-                TreeType treeType = SaplingBlock.treeType;
-                SaplingBlock.treeType = null;
+                TreeType treeType = SaplingBlock.treeTypeRT.get(); // SparklyPaper - parallel world ticking
+                SaplingBlock.treeTypeRT.set(null); // SparklyPaper - parallel world ticking
                 List<CraftBlockState> blocks = new java.util.ArrayList<>(world.capturedBlockStates.values());
                 world.capturedBlockStates.clear();
                 StructureGrowEvent structureEvent = null;
diff --git a/src/main/java/net/minecraft/world/item/MinecartItem.java b/src/main/java/net/minecraft/world/item/MinecartItem.java
index 4b8cebb321eddc852b4ec7def7f51d781f67927b..566ab63c0ca05094a58ac809ae899e6d01b206dc 100644
--- a/src/main/java/net/minecraft/world/item/MinecartItem.java
+++ b/src/main/java/net/minecraft/world/item/MinecartItem.java
@@ -71,7 +71,7 @@ public class MinecartItem extends Item {
             CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
 
             BlockDispenseEvent event = new BlockDispenseEvent(block2, craftItem.clone(), new org.bukkit.util.Vector(d0, d1 + d3, d2));
-            if (!DispenserBlock.eventFired) {
+            if (!DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
                 worldserver.getCraftServer().getPluginManager().callEvent(event);
             }
 
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 08b5be2cc7600b4be6e75e31dc738d019ee8efe8..69e85260af78b8e289b4e39890c2fc3d18248831 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -174,6 +174,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     // Paper end - add paper world config
 
     public final com.destroystokyo.paper.antixray.ChunkPacketBlockController chunkPacketBlockController; // Paper - Anti-Xray
+    public com.destroystokyo.paper.util.RedstoneWireTurbo turbo = new com.destroystokyo.paper.util.RedstoneWireTurbo((net.minecraft.world.level.block.RedStoneWireBlock) net.minecraft.world.level.block.Blocks.REDSTONE_WIRE); // SparklyPaper - parallel world ticking (moved to world)
     public final org.purpurmc.purpur.PurpurWorldConfig purpurConfig; // Purpur
     public final co.aikar.timings.WorldTimingsHandler timings; // Paper
     public static BlockPos lastPhysicsProblem; // Spigot
@@ -1061,6 +1062,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
 
     @Override
     public boolean setBlock(BlockPos pos, BlockState state, int flags, int maxUpdateDepth) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread((ServerLevel)this, pos, "Updating block asynchronously"); // SparklyPaper - parallel world ticking (additional concurrency issues logs)
         // CraftBukkit start - tree generation
         if (this.captureTreeGeneration) {
             // Paper start - Protect Bedrock and End Portal/Frames from being destroyed
@@ -1448,7 +1450,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
                 tickingblockentity.tick();
                 // Paper start - rewrite chunk system
                 if ((++tickedEntities & 7) == 0) {
-                    ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)(Level)(Object)this).moonrise$midTickTasks();
+                    // ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)(Level)(Object)this).moonrise$midTickTasks();
                 }
                 // Paper end - rewrite chunk system
             }
@@ -1474,7 +1476,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
             entity.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.DISCARD); // Pufferfish - diff on change ServerLevel.tick
             // Paper end - Prevent block entity and entity crashes
         }
-        this.moonrise$midTickTasks(); // Paper - rewrite chunk system // Pufferfish - diff on change ServerLevel.tick
+        // this.moonrise$midTickTasks(); // Paper - rewrite chunk system // Pufferfish - diff on change ServerLevel.tick
     }
     // Paper start - Option to prevent armor stands from doing entity lookups
     @Override
@@ -1591,6 +1593,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
 
     @Nullable
     public BlockEntity getBlockEntity(BlockPos blockposition, boolean validate) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThreadOrAsyncThread((ServerLevel) this, "Cannot read world asynchronously"); // SparklyPaper start - parallel world ticking
         // Paper start - Perf: Optimize capturedTileEntities lookup
         net.minecraft.world.level.block.entity.BlockEntity blockEntity;
         if (!this.capturedTileEntities.isEmpty() && (blockEntity = this.capturedTileEntities.get(blockposition)) != null) {
@@ -1602,6 +1605,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     }
 
     public void setBlockEntity(BlockEntity blockEntity) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread((ServerLevel) this, "Cannot modify world asynchronously"); // SparklyPaper start - parallel world ticking
         BlockPos blockposition = blockEntity.getBlockPos();
 
         if (!this.isOutsideBuildHeight(blockposition)) {
@@ -1687,6 +1691,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
 
     @Override
     public List<Entity> getEntities(@Nullable Entity except, AABB box, Predicate<? super Entity> predicate) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread((ServerLevel)this, box, "Cannot getEntities asynchronously"); // SparklyPaper - parallel world ticking (additional concurrency issues logs)
         //this.getProfiler().incrementCounter("getEntities"); // Purpur
         // Paper start - rewrite chunk system
         final List<Entity> ret = new java.util.ArrayList<>();
@@ -1997,8 +2002,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     public abstract RecipeManager getRecipeManager();
 
     public BlockPos getBlockRandomPos(int x, int y, int z, int l) {
-        this.randValue = this.randValue * 3 + 1013904223;
-        int i1 = this.randValue >> 2;
+        int i1 = this.random.nextInt() >> 2; // SparklyPaper - parallel world ticking
 
         return new BlockPos(x + (i1 & 15), y + (i1 >> 16 & l), z + (i1 >> 8 & 15));
     }
diff --git a/src/main/java/net/minecraft/world/level/block/DispenserBlock.java b/src/main/java/net/minecraft/world/level/block/DispenserBlock.java
index e1021d8be840f378568f28639c259182055c78ac..d8728bed4aaff697af2f4051afbe779481ae61dd 100644
--- a/src/main/java/net/minecraft/world/level/block/DispenserBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/DispenserBlock.java
@@ -51,7 +51,8 @@ public class DispenserBlock extends BaseEntityBlock {
         object2objectopenhashmap.defaultReturnValue(DispenserBlock.DEFAULT_BEHAVIOR);
     });
     private static final int TRIGGER_DURATION = 4;
-    public static boolean eventFired = false; // CraftBukkit
+    // public static boolean eventFired = false; // CraftBukkit // SparklyPaper - parallel world ticking
+    public static ThreadLocal<Boolean> eventFired = ThreadLocal.withInitial(() -> Boolean.FALSE); // SparklyPaper - parallel world ticking
 
     @Override
     public MapCodec<? extends DispenserBlock> codec() {
@@ -110,7 +111,7 @@ public class DispenserBlock extends BaseEntityBlock {
 
                 if (idispensebehavior != DispenseItemBehavior.NOOP) {
                     if (!org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockPreDispenseEvent(world, pos, itemstack, i)) return; // Paper - Add BlockPreDispenseEvent
-                    DispenserBlock.eventFired = false; // CraftBukkit - reset event status
+                    DispenserBlock.eventFired.set(Boolean.FALSE); // CraftBukkit - reset event status // SparklyPaper - parallel world ticking
                     tileentitydispenser.setItem(i, idispensebehavior.dispense(sourceblock, itemstack));
                 }
 
diff --git a/src/main/java/net/minecraft/world/level/block/FungusBlock.java b/src/main/java/net/minecraft/world/level/block/FungusBlock.java
index 454f95ba814b375e97189430b498c0e7486fbd94..8f5dc8a06a4d58cbc5f5ee27e0d0b384405e2c94 100644
--- a/src/main/java/net/minecraft/world/level/block/FungusBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/FungusBlock.java
@@ -76,9 +76,9 @@ public class FungusBlock extends BushBlock implements BonemealableBlock {
         this.getFeature(world).ifPresent((holder) -> {
             // CraftBukkit start
             if (this == Blocks.WARPED_FUNGUS) {
-                SaplingBlock.treeType = org.bukkit.TreeType.WARPED_FUNGUS;
+                SaplingBlock.treeTypeRT.set(org.bukkit.TreeType.WARPED_FUNGUS); // SparklyPaper - parallel world ticking
             } else if (this == Blocks.CRIMSON_FUNGUS) {
-                SaplingBlock.treeType = org.bukkit.TreeType.CRIMSON_FUNGUS;
+                SaplingBlock.treeTypeRT.set(org.bukkit.TreeType.CRIMSON_FUNGUS); // SparklyPaper - parallel world ticking
             }
             // CraftBukkit end
             ((ConfiguredFeature) holder.value()).place(world, world.getChunkSource().getGenerator(), random, pos);
diff --git a/src/main/java/net/minecraft/world/level/block/MushroomBlock.java b/src/main/java/net/minecraft/world/level/block/MushroomBlock.java
index 1172d85c5c26ab2142343d91149766e5993cb36a..54a5533761329237c3bf4304e2b0b652e62f5877 100644
--- a/src/main/java/net/minecraft/world/level/block/MushroomBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/MushroomBlock.java
@@ -105,7 +105,7 @@ public class MushroomBlock extends BushBlock implements BonemealableBlock {
             return false;
         } else {
             world.removeBlock(pos, false);
-            SaplingBlock.treeType = (this == Blocks.BROWN_MUSHROOM) ? TreeType.BROWN_MUSHROOM : TreeType.RED_MUSHROOM; // CraftBukkit
+            SaplingBlock.treeTypeRT.set((this == Blocks.BROWN_MUSHROOM) ? TreeType.BROWN_MUSHROOM : TreeType.RED_MUSHROOM); // CraftBukkit // SparklyPaper - parallel world ticking
             if (((ConfiguredFeature) ((Holder) optional.get()).value()).place(world, world.getChunkSource().getGenerator(), random, pos)) {
                 return true;
             } else {
diff --git a/src/main/java/net/minecraft/world/level/block/RedStoneWireBlock.java b/src/main/java/net/minecraft/world/level/block/RedStoneWireBlock.java
index c131734cad123a35456d18f8a161f77a4ac9ac99..cdadd4b2893a3377e8a72112976cb683057eacf8 100644
--- a/src/main/java/net/minecraft/world/level/block/RedStoneWireBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/RedStoneWireBlock.java
@@ -260,7 +260,7 @@ public class RedStoneWireBlock extends Block {
 
     // Paper start - Optimize redstone (Eigencraft)
     // The bulk of the new functionality is found in RedstoneWireTurbo.java
-    com.destroystokyo.paper.util.RedstoneWireTurbo turbo = new com.destroystokyo.paper.util.RedstoneWireTurbo(this);
+    // com.destroystokyo.paper.util.RedstoneWireTurbo turbo = new com.destroystokyo.paper.util.RedstoneWireTurbo(this);
 
     /*
      * Modified version of pre-existing updateSurroundingRedstone, which is called from
@@ -269,7 +269,7 @@ public class RedStoneWireBlock extends Block {
      */
     private void updateSurroundingRedstone(Level worldIn, BlockPos pos, BlockState state, BlockPos source) {
         if (worldIn.paperConfig().misc.redstoneImplementation == io.papermc.paper.configuration.WorldConfiguration.Misc.RedstoneImplementation.EIGENCRAFT) {
-            turbo.updateSurroundingRedstone(worldIn, pos, state, source);
+            worldIn.turbo.updateSurroundingRedstone(worldIn, pos, state, source); // turbo.updateSurroundingRedstone(worldIn, pos, state, source); // SparklyPaper - parallel world ticking
             return;
         }
         updatePowerStrength(worldIn, pos, state);
@@ -360,7 +360,7 @@ public class RedStoneWireBlock extends Block {
                 // [Space Walker] suppress shape updates and emit those manually to
                 // bypass the new neighbor update stack.
                 if (worldIn.setBlock(pos1, state, Block.UPDATE_KNOWN_SHAPE | Block.UPDATE_CLIENTS))
-                    turbo.updateNeighborShapes(worldIn, pos1, state);
+                    worldIn.turbo.updateNeighborShapes(worldIn, pos1, state); // turbo.updateNeighborShapes(worldIn, pos1, state); // SparklyPaper - parallel world ticking
             }
         }
 
diff --git a/src/main/java/net/minecraft/world/level/block/SaplingBlock.java b/src/main/java/net/minecraft/world/level/block/SaplingBlock.java
index d262a5a6da57ef9ba9a6fe0dfbc88f577105e74f..15db3fb971a944e856b3cde86035d290673c0c1a 100644
--- a/src/main/java/net/minecraft/world/level/block/SaplingBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/SaplingBlock.java
@@ -35,7 +35,7 @@ public class SaplingBlock extends BushBlock implements BonemealableBlock {
     protected static final float AABB_OFFSET = 6.0F;
     protected static final VoxelShape SHAPE = Block.box(2.0D, 0.0D, 2.0D, 14.0D, 12.0D, 14.0D);
     protected final TreeGrower treeGrower;
-    public static TreeType treeType; // CraftBukkit
+    public static final ThreadLocal<TreeType> treeTypeRT = new ThreadLocal<>(); // CraftBukkit // SparklyPaper - parallel world ticking (from Folia)
 
     @Override
     public MapCodec<? extends SaplingBlock> codec() {
@@ -73,8 +73,8 @@ public class SaplingBlock extends BushBlock implements BonemealableBlock {
                 this.treeGrower.growTree(world, world.getChunkSource().getGenerator(), pos, state, random);
                 world.captureTreeGeneration = false;
                 if (world.capturedBlockStates.size() > 0) {
-                    TreeType treeType = SaplingBlock.treeType;
-                    SaplingBlock.treeType = null;
+                    TreeType treeType = SaplingBlock.treeTypeRT.get(); // SparklyPaper - parallel world ticking
+                    SaplingBlock.treeTypeRT.set(null); // SparklyPaper - parallel world ticking
                     Location location = CraftLocation.toBukkit(pos, world.getWorld());
                     java.util.List<BlockState> blocks = new java.util.ArrayList<>(world.capturedBlockStates.values());
                     world.capturedBlockStates.clear();
diff --git a/src/main/java/net/minecraft/world/level/block/entity/BaseContainerBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/BaseContainerBlockEntity.java
index 2ddf349fde5b310ec3f74baee1f3d33e09d5286c..fe9c3479b61f79ed8ce3659d4e1ead8c9598ea8b 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/BaseContainerBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/BaseContainerBlockEntity.java
@@ -82,6 +82,12 @@ public abstract class BaseContainerBlockEntity extends BlockEntity implements Co
         return canUnlock(player, lock, containerName, null);
     }
     public static boolean canUnlock(Player player, LockCode lock, Component containerName, @Nullable BlockEntity blockEntity) {
+        // SparklyPaper - parallel world ticking (see: PARALLEL_NOTES.md - Opening an inventory after a world switch)
+        if (player instanceof net.minecraft.server.level.ServerPlayer serverPlayer && blockEntity != null && blockEntity.getLevel() != serverPlayer.serverLevel()) {
+            net.minecraft.server.MinecraftServer.LOGGER.warn("Player " + serverPlayer.getScoreboardName() + " (" + serverPlayer.getStringUUID() + ") attempted to open a BlockEntity @ " + blockEntity.getLevel().getWorld().getName() + " " + blockEntity.getBlockPos().getX() + ", " + blockEntity.getBlockPos().getY() + ", " + blockEntity.getBlockPos().getZ() + " while they were in a different world " + serverPlayer.level().getWorld().getName() + " than the block themselves!");
+            return false;
+        }
+        // SparklyPaper end
         if (player instanceof net.minecraft.server.level.ServerPlayer serverPlayer && blockEntity != null && blockEntity.getLevel() != null && blockEntity.getLevel().getBlockEntity(blockEntity.getBlockPos()) == blockEntity) {
             final org.bukkit.block.Block block = org.bukkit.craftbukkit.block.CraftBlock.at(blockEntity.getLevel(), blockEntity.getBlockPos());
             net.kyori.adventure.text.Component lockedMessage = net.kyori.adventure.text.Component.translatable("container.isLocked", io.papermc.paper.adventure.PaperAdventure.asAdventure(containerName));
diff --git a/src/main/java/net/minecraft/world/level/block/entity/SculkCatalystBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/SculkCatalystBlockEntity.java
index a74732902c0494c67e6acf2fc04581ff9c46b832..fe9d7f0f800222c6eaafa903562c6106c09e84f2 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/SculkCatalystBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/SculkCatalystBlockEntity.java
@@ -46,9 +46,9 @@ public class SculkCatalystBlockEntity extends BlockEntity implements GameEventLi
     // Paper end - Fix NPE in SculkBloomEvent world access
 
     public static void serverTick(Level world, BlockPos pos, BlockState state, SculkCatalystBlockEntity blockEntity) {
-        org.bukkit.craftbukkit.event.CraftEventFactory.sourceBlockOverride = blockEntity.getBlockPos(); // CraftBukkit - SPIGOT-7068: Add source block override, not the most elegant way but better than passing down a BlockPosition up to five methods deep.
+        org.bukkit.craftbukkit.event.CraftEventFactory.sourceBlockOverrideRT.set(blockEntity.getBlockPos()); // SparklyPaper - parallel world ticking // CraftBukkit - SPIGOT-7068: Add source block override, not the most elegant way but better than passing down a BlockPosition up to five methods deep.
         blockEntity.catalystListener.getSculkSpreader().updateCursors(world, pos, world.getRandom(), true);
-        org.bukkit.craftbukkit.event.CraftEventFactory.sourceBlockOverride = null; // CraftBukkit
+        org.bukkit.craftbukkit.event.CraftEventFactory.sourceBlockOverrideRT.set(null); // SparklyPaper - parallel world ticking // CraftBukkit
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/block/grower/TreeGrower.java b/src/main/java/net/minecraft/world/level/block/grower/TreeGrower.java
index 597599138f69c9ee05dc7657c51c25336337875e..c9876514091f5cd0fc9c24b4f1577b1aef9f24e6 100644
--- a/src/main/java/net/minecraft/world/level/block/grower/TreeGrower.java
+++ b/src/main/java/net/minecraft/world/level/block/grower/TreeGrower.java
@@ -174,51 +174,53 @@ public final class TreeGrower {
     // CraftBukkit start
     private void setTreeType(Holder<ConfiguredFeature<?, ?>> holder) {
         ResourceKey<ConfiguredFeature<?, ?>> worldgentreeabstract = holder.unwrapKey().get();
+        TreeType treeType; // SparklyPaper - parallel world ticking
         if (worldgentreeabstract == TreeFeatures.OAK || worldgentreeabstract == TreeFeatures.OAK_BEES_005) {
-            SaplingBlock.treeType = TreeType.TREE;
+            treeType = TreeType.TREE;
         } else if (worldgentreeabstract == TreeFeatures.HUGE_RED_MUSHROOM) {
-            SaplingBlock.treeType = TreeType.RED_MUSHROOM;
+            treeType = TreeType.RED_MUSHROOM;
         } else if (worldgentreeabstract == TreeFeatures.HUGE_BROWN_MUSHROOM) {
-            SaplingBlock.treeType = TreeType.BROWN_MUSHROOM;
+            treeType = TreeType.BROWN_MUSHROOM;
         } else if (worldgentreeabstract == TreeFeatures.JUNGLE_TREE) {
-            SaplingBlock.treeType = TreeType.COCOA_TREE;
+            treeType = TreeType.COCOA_TREE;
         } else if (worldgentreeabstract == TreeFeatures.JUNGLE_TREE_NO_VINE) {
-            SaplingBlock.treeType = TreeType.SMALL_JUNGLE;
+            treeType = TreeType.SMALL_JUNGLE;
         } else if (worldgentreeabstract == TreeFeatures.PINE) {
-            SaplingBlock.treeType = TreeType.TALL_REDWOOD;
+            treeType = TreeType.TALL_REDWOOD;
         } else if (worldgentreeabstract == TreeFeatures.SPRUCE) {
-            SaplingBlock.treeType = TreeType.REDWOOD;
+            treeType = TreeType.REDWOOD;
         } else if (worldgentreeabstract == TreeFeatures.ACACIA) {
-            SaplingBlock.treeType = TreeType.ACACIA;
+            treeType = TreeType.ACACIA;
         } else if (worldgentreeabstract == TreeFeatures.BIRCH || worldgentreeabstract == TreeFeatures.BIRCH_BEES_005) {
-            SaplingBlock.treeType = TreeType.BIRCH;
+            treeType = TreeType.BIRCH;
         } else if (worldgentreeabstract == TreeFeatures.SUPER_BIRCH_BEES_0002) {
-            SaplingBlock.treeType = TreeType.TALL_BIRCH;
+            treeType = TreeType.TALL_BIRCH;
         } else if (worldgentreeabstract == TreeFeatures.SWAMP_OAK) {
-            SaplingBlock.treeType = TreeType.SWAMP;
+            treeType = TreeType.SWAMP;
         } else if (worldgentreeabstract == TreeFeatures.FANCY_OAK || worldgentreeabstract == TreeFeatures.FANCY_OAK_BEES_005) {
-            SaplingBlock.treeType = TreeType.BIG_TREE;
+            treeType = TreeType.BIG_TREE;
         } else if (worldgentreeabstract == TreeFeatures.JUNGLE_BUSH) {
-            SaplingBlock.treeType = TreeType.JUNGLE_BUSH;
+            treeType = TreeType.JUNGLE_BUSH;
         } else if (worldgentreeabstract == TreeFeatures.DARK_OAK) {
-            SaplingBlock.treeType = TreeType.DARK_OAK;
+            treeType = TreeType.DARK_OAK;
         } else if (worldgentreeabstract == TreeFeatures.MEGA_SPRUCE) {
-            SaplingBlock.treeType = TreeType.MEGA_REDWOOD;
+            treeType = TreeType.MEGA_REDWOOD;
         } else if (worldgentreeabstract == TreeFeatures.MEGA_PINE) {
-            SaplingBlock.treeType = TreeType.MEGA_PINE;
+            treeType = TreeType.MEGA_PINE;
         } else if (worldgentreeabstract == TreeFeatures.MEGA_JUNGLE_TREE) {
-            SaplingBlock.treeType = TreeType.JUNGLE;
+            treeType = TreeType.JUNGLE;
         } else if (worldgentreeabstract == TreeFeatures.AZALEA_TREE) {
-            SaplingBlock.treeType = TreeType.AZALEA;
+            treeType = TreeType.AZALEA;
         } else if (worldgentreeabstract == TreeFeatures.MANGROVE) {
-            SaplingBlock.treeType = TreeType.MANGROVE;
+            treeType = TreeType.MANGROVE;
         } else if (worldgentreeabstract == TreeFeatures.TALL_MANGROVE) {
-            SaplingBlock.treeType = TreeType.TALL_MANGROVE;
+            treeType = TreeType.TALL_MANGROVE;
         } else if (worldgentreeabstract == TreeFeatures.CHERRY || worldgentreeabstract == TreeFeatures.CHERRY_BEES_005) {
-            SaplingBlock.treeType = TreeType.CHERRY;
+            treeType = TreeType.CHERRY;
         } else {
             throw new IllegalArgumentException("Unknown tree generator " + worldgentreeabstract);
         }
+        SaplingBlock.treeTypeRT.set(treeType); // SparklyPaper - parallel world ticking
     }
     // CraftBukkit end
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index a4578ae22409edb686d0bcbac8cbc1a2e1d7b988..6d95002c29c2c5b362cdf4a4a21a06327f5f0bab 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -366,6 +366,7 @@ public class LevelChunk extends ChunkAccess implements ca.spottedleaf.moonrise.p
 
     @Nullable
     public BlockState setBlockState(BlockPos blockposition, BlockState iblockdata, boolean flag, boolean doPlace) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.level, blockposition, "Updating block asynchronously"); // SparklyPaper - parallel world ticking (additional concurrency issues logs)
         // CraftBukkit end
         int i = blockposition.getY();
         LevelChunkSection chunksection = this.getSection(this.getSectionIndex(i));
diff --git a/src/main/java/net/minecraft/world/level/entity/EntityTickList.java b/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
index 80a43def4912a3228cd95117d5c2aac68798b4ec..4e51567d88890702038f1e9c4282ad30bf9f2511 100644
--- a/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
+++ b/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
@@ -10,17 +10,26 @@ import net.minecraft.world.entity.Entity;
 
 public class EntityTickList {
     public final ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet<net.minecraft.world.entity.Entity> entities = new ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet<>(); // Paper - rewrite chunk system // Pufferfish - private->public
+    // SparklyPaper start - parallel world ticking
+    // Used to track async entity additions/removals/loops
+    private final net.minecraft.server.level.ServerLevel serverLevel;
+    public EntityTickList(net.minecraft.server.level.ServerLevel serverLevel) {
+        this.serverLevel = serverLevel;
+    }
+    // SparklyPaper end
 
     private void ensureActiveIsNotIterated() {
         // Paper - rewrite chunk system
     }
 
     public void add(Entity entity) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(entity, "Asynchronous entity ticklist addition"); // Paper // SparklyPaper - parallel world ticking (additional concurrency issues logs)
         this.ensureActiveIsNotIterated();
         this.entities.add(entity); // Paper - rewrite chunk system
     }
 
     public void remove(Entity entity) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(entity, "Asynchronous entity ticklist removal"); // Paper // SparklyPaper - parallel world ticking (additional concurrency issues logs)
         this.ensureActiveIsNotIterated();
         this.entities.remove(entity); // Paper - rewrite chunk system
     }
@@ -30,7 +39,7 @@ public class EntityTickList {
     }
 
     public void forEach(Consumer<Entity> action) {
-        // Paper start - rewrite chunk system
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverLevel, "Asynchronous entity ticklist iteration"); // Paper // SparklyPaper - parallel world ticking (additional concurrency issues logs)
         // To ensure nothing weird happens with dimension travelling, do not iterate over new entries...
         // (by dfl iterator() is configured to not iterate over new entries)
         final ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet.Iterator<Entity> iterator = this.entities.iterator();
diff --git a/src/main/java/net/minecraft/world/level/saveddata/maps/MapIndex.java b/src/main/java/net/minecraft/world/level/saveddata/maps/MapIndex.java
index 763b315b1d761bc3bd82d9b847ed3f64fd5ce991..cc274658b6f4e663f3941b0e81c742b78e39e30d 100644
--- a/src/main/java/net/minecraft/world/level/saveddata/maps/MapIndex.java
+++ b/src/main/java/net/minecraft/world/level/saveddata/maps/MapIndex.java
@@ -34,17 +34,21 @@ public class MapIndex extends SavedData {
 
     @Override
     public CompoundTag save(CompoundTag nbt, HolderLookup.Provider registryLookup) {
-        for (Entry<String> entry : this.usedAuxIds.object2IntEntrySet()) {
-            nbt.putInt(entry.getKey(), entry.getIntValue());
-        }
+        synchronized (this.usedAuxIds) { // SparklyPaper start - make map data thread-safe
+            for (Entry<String> entry : this.usedAuxIds.object2IntEntrySet()) {
+                nbt.putInt(entry.getKey(), entry.getIntValue());
+            }
+        } // SparklyPaper end - make map data thread-safe
 
         return nbt;
     }
 
     public MapId getFreeAuxValueForMap() {
-        int i = this.usedAuxIds.getInt("map") + 1;
-        this.usedAuxIds.put("map", i);
-        this.setDirty();
-        return new MapId(i);
+        synchronized (this.usedAuxIds) { // SparklyPaper start - make map data thread-safe
+            int i = this.usedAuxIds.getInt("map") + 1;
+            this.usedAuxIds.put("map", i);
+            this.setDirty();
+            return new MapId(i);
+        } // SparklyPaper end - make map data thread-safe
     }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 022fae208dc858917c4c63b6274e4f6423bc5bb2..54b55df9de6f7cc86ab01215a03e2c90fce7e15a 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -1086,6 +1086,7 @@ public final class CraftServer implements Server {
 
         org.spigotmc.SpigotConfig.init((File) this.console.options.valueOf("spigot-settings")); // Spigot
         this.console.paperConfigurations.reloadConfigs(this.console);
+        net.sparklypower.sparklypaper.configs.SparklyPaperConfigUtils.INSTANCE.init((File) console.options.valueOf("sparklypaper-settings")); // SparklyPaper
         org.purpurmc.purpur.PurpurConfig.init((File) console.options.valueOf("purpur-settings")); // Purpur
         for (ServerLevel world : this.console.getAllLevels()) {
             // world.serverLevelData.setDifficulty(config.difficulty); // Paper - per level difficulty
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 0921894dbc0d81b943827ecda6e6befdbfd715f5..785aaa05190639b29ab61f693780b2aeda7e1f43 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -474,7 +474,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     }
 
     private boolean unloadChunk0(int x, int z, boolean save) {
-        org.spigotmc.AsyncCatcher.catchOp("chunk unload"); // Spigot
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.world, x, z, "Cannot unload chunk asynchronously"); // SparklyPaper - parallel world ticking (additional concurrency issues logs)
         if (!this.isChunkLoaded(x, z)) {
             return true;
         }
@@ -489,7 +489,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public boolean regenerateChunk(int x, int z) {
-        org.spigotmc.AsyncCatcher.catchOp("chunk regenerate"); // Spigot
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.world, x, z, "Cannot regenerate chunk asynchronously"); // SparklyPaper - parallel world ticking (additional concurrency issues logs)
         throw new UnsupportedOperationException("Not supported in this Minecraft version! Unless you can fix it, this is not a bug :)");
         /*
         if (!unloadChunk0(x, z, false)) {
@@ -516,6 +516,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public boolean refreshChunk(int x, int z) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.world, x, z, "Cannot refresh chunk asynchronously"); // SparklyPaper - parallel world ticking (additional concurrency issues logs)
         ChunkHolder playerChunk = this.world.getChunkSource().chunkMap.getVisibleChunkIfPresent(ChunkPos.asLong(x, z));
         if (playerChunk == null) return false;
 
@@ -576,7 +577,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public boolean loadChunk(int x, int z, boolean generate) {
-        org.spigotmc.AsyncCatcher.catchOp("chunk load"); // Spigot
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.getHandle(), x, z, "May not sync load chunks asynchronously"); // SparklyPaper - parallel world ticking (additional concurrency issues logs)
         warnUnsafeChunk("loading a faraway chunk", x, z); // Paper
         ChunkAccess chunk = this.world.getChunkSource().getChunk(x, z, generate || isChunkGenerated(x, z) ? ChunkStatus.FULL : ChunkStatus.EMPTY, true); // Paper
 
@@ -828,6 +829,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public boolean generateTree(Location loc, TreeType type, BlockChangeDelegate delegate) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.world, loc.getX(), loc.getZ(), "Cannot generate tree asynchronously"); // SparklyPaper - parallel world ticking (additional concurrency issues logs)
         this.world.captureTreeGeneration = true;
         this.world.captureBlockStates = true;
         boolean grownTree = this.generateTree(loc, type);
@@ -938,6 +940,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public boolean createExplosion(double x, double y, double z, float power, boolean setFire, boolean breakBlocks, Entity source) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.world, x, z, "Cannot create explosion asynchronously"); // SparklyPaper - parallel world ticking (additional concurrency issues logs)
         net.minecraft.world.level.Level.ExplosionInteraction explosionType;
         if (!breakBlocks) {
             explosionType = net.minecraft.world.level.Level.ExplosionInteraction.NONE; // Don't break blocks
@@ -952,6 +955,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     // Paper start
     @Override
     public boolean createExplosion(Entity source, Location loc, float power, boolean setFire, boolean breakBlocks, boolean excludeSourceFromDamage) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(world, loc.getX(), loc.getZ(), "Cannot create explosion asynchronously"); // SparklyPaper - parallel world ticking (additional concurrency issues logs)
         return !world.explode(source != null ? ((org.bukkit.craftbukkit.entity.CraftEntity) source).getHandle() : null, loc.getX(), loc.getY(), loc.getZ(), power, setFire, breakBlocks ? net.minecraft.world.level.Level.ExplosionInteraction.MOB : net.minecraft.world.level.Level.ExplosionInteraction.NONE, explosion -> {
             explosion.excludeSourceFromDamage = excludeSourceFromDamage;
         }).wasCanceled;
@@ -1030,6 +1034,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public int getHighestBlockYAt(int x, int z, org.bukkit.HeightMap heightMap) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.world, x >> 4, z >> 4, "Cannot retrieve chunk asynchronously"); // SparklyPaper - parallel world ticking (additional concurrency issues logs)
         warnUnsafeChunk("getting a faraway chunk", x >> 4, z >> 4); // Paper
         // Transient load for this tick
         return this.world.getChunk(x >> 4, z >> 4).getHeight(CraftHeightMap.toNMS(heightMap), x, z);
@@ -1060,6 +1065,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     public void setBiome(int x, int y, int z, Holder<net.minecraft.world.level.biome.Biome> bb) {
         BlockPos pos = new BlockPos(x, 0, z);
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.world, pos, "Cannot retrieve chunk asynchronously"); // SparklyPaper - parallel world ticking (additional concurrency issues logs)
         if (this.world.hasChunkAt(pos)) {
             net.minecraft.world.level.chunk.LevelChunk chunk = this.world.getChunkAt(pos);
 
@@ -2329,6 +2335,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void sendGameEvent(Entity sourceEntity, org.bukkit.GameEvent gameEvent, Vector position) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.world, position.getX(), position.getZ(), "Cannot send game event asynchronously"); // SparklyPaper - parallel world ticking (additional concurrency issues logs)
         getHandle().gameEvent(sourceEntity != null ? ((CraftEntity) sourceEntity).getHandle(): null, net.minecraft.core.registries.BuiltInRegistries.GAME_EVENT.getHolder(org.bukkit.craftbukkit.util.CraftNamespacedKey.toMinecraft(gameEvent.getKey())).orElseThrow(), org.bukkit.craftbukkit.util.CraftVector.toBlockPos(position));
     }
     // Paper end
@@ -2496,7 +2503,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     // Paper start
     public java.util.concurrent.CompletableFuture<Chunk> getChunkAtAsync(int x, int z, boolean gen, boolean urgent) {
         warnUnsafeChunk("getting a faraway chunk async", x, z); // Paper
-        if (Bukkit.isPrimaryThread()) {
+        if (ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(this.getHandle(), x, z)) { // SparklyPaper - parallel world ticking
             net.minecraft.world.level.chunk.LevelChunk immediate = this.world.getChunkSource().getChunkAtIfLoadedImmediately(x, z);
             if (immediate != null) {
                 return java.util.concurrent.CompletableFuture.completedFuture(new CraftChunk(immediate));
diff --git a/src/main/java/org/bukkit/craftbukkit/Main.java b/src/main/java/org/bukkit/craftbukkit/Main.java
index 068aa459b4d1dfbbbd80dc0ae5c43b8202474477..85e80312fef5a8b131589cddf7c1e5923758674c 100644
--- a/src/main/java/org/bukkit/craftbukkit/Main.java
+++ b/src/main/java/org/bukkit/craftbukkit/Main.java
@@ -190,6 +190,14 @@ public class Main {
                         .describedAs("Yml file");
                 // Purpur end
 
+                // SparklyPaper Start
+                acceptsAll(asList("sparklypaper", "sparklypaper-settings"), "File for SparklyPaper settings")
+                        .withRequiredArg()
+                        .ofType(File.class)
+                        .defaultsTo(new File("sparklypaper.yml"))
+                        .describedAs("Yml file");
+                // SparklyPaper end
+
                 // Paper start
                 acceptsAll(asList("server-name"), "Name of the server")
                         .withRequiredArg()
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
index ac11f18690434922179b61ffcc3036dea025b0cb..59b8136ebd0100f0f8e6ded002486b37415ddc73 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
@@ -75,6 +75,11 @@ public class CraftBlock implements Block {
     }
 
     public net.minecraft.world.level.block.state.BlockState getNMS() {
+        // Folia start - parallel world ticking
+        if (world instanceof ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, position, "Cannot read world asynchronously");
+        }
+        // Folia end - parallel world ticking
         return this.world.getBlockState(this.position);
     }
 
@@ -157,6 +162,11 @@ public class CraftBlock implements Block {
     }
 
     private void setData(final byte data, int flag) {
+        // SparklyPaper start - parallel world ticking
+        if (world instanceof ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, position, "Cannot modify world asynchronously");
+        }
+        // SparklyPaper end - parallel world ticking
         this.world.setBlock(this.position, CraftMagicNumbers.getBlock(this.getType(), data), flag);
     }
 
@@ -198,6 +208,12 @@ public class CraftBlock implements Block {
     }
 
     public static boolean setTypeAndData(LevelAccessor world, BlockPos position, net.minecraft.world.level.block.state.BlockState old, net.minecraft.world.level.block.state.BlockState blockData, boolean applyPhysics) {
+        // SparklyPaper start - parallel world ticking
+        if (world instanceof ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, position, "Cannot modify world asynchronously");
+        }
+        // SparklyPaper end - parallel world ticking
+
         // SPIGOT-611: need to do this to prevent glitchiness. Easier to handle this here (like /setblock) than to fix weirdness in tile entity cleanup
         if (old.hasBlockEntity() && blockData.getBlock() != old.getBlock()) { // SPIGOT-3725 remove old tile entity if block changes
             // SPIGOT-4612: faster - just clear tile
@@ -343,18 +359,33 @@ public class CraftBlock implements Block {
 
     @Override
     public Biome getBiome() {
+        // SparklyPaper start - parallel world ticking
+        if (world instanceof ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, position, "Cannot read world asynchronously");
+        }
+        // SparklyPaper end - parallel world ticking
         return this.getWorld().getBiome(this.getX(), this.getY(), this.getZ());
     }
 
     // Paper start
     @Override
     public Biome getComputedBiome() {
+        // SparklyPaper start - parallel world ticking
+        if (world instanceof ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, position, "Cannot read world asynchronously");
+        }
+        // SparklyPaper end - parallel world ticking
         return this.getWorld().getComputedBiome(this.getX(), this.getY(), this.getZ());
     }
     // Paper end
 
     @Override
     public void setBiome(Biome bio) {
+        // SparklyPaper start - parallel world ticking
+        if (world instanceof ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, position, "Cannot modify world asynchronously");
+        }
+        // SparklyPaper end - parallel world ticking
         this.getWorld().setBiome(this.getX(), this.getY(), this.getZ(), bio);
     }
 
@@ -402,6 +433,11 @@ public class CraftBlock implements Block {
 
     @Override
     public boolean isBlockFaceIndirectlyPowered(BlockFace face) {
+        // SparklyPaper start - parallel world ticking
+        if (world instanceof ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, position, "Cannot read world asynchronously");
+        }
+        // SparklyPaper end - parallel world ticking
         int power = this.world.getMinecraftWorld().getSignal(this.position, CraftBlock.blockFaceToNotch(face));
 
         Block relative = this.getRelative(face);
@@ -414,6 +450,11 @@ public class CraftBlock implements Block {
 
     @Override
     public int getBlockPower(BlockFace face) {
+        // SparklyPaper start - parallel world ticking
+        if (world instanceof ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, position, "Cannot read world asynchronously");
+        }
+        // SparklyPaper end - parallel world ticking
         int power = 0;
         net.minecraft.world.level.Level world = this.world.getMinecraftWorld();
         int x = this.getX();
@@ -484,6 +525,11 @@ public class CraftBlock implements Block {
 
     @Override
     public boolean breakNaturally() {
+        // SparklyPaper start - parallel world ticking
+        if (world instanceof ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, position, "Cannot modify world asynchronously");
+        }
+        // SparklyPaper end - parallel world ticking
         return this.breakNaturally(null);
     }
 
@@ -543,6 +589,11 @@ public class CraftBlock implements Block {
 
     @Override
     public boolean applyBoneMeal(BlockFace face) {
+        // SparklyPaper start - parallel world ticking
+        if (world instanceof ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, position, "Cannot modify world asynchronously");
+        }
+        // SparklyPaper end - parallel world ticking
         Direction direction = CraftBlock.blockFaceToNotch(face);
         BlockFertilizeEvent event = null;
         ServerLevel world = this.getCraftWorld().getHandle();
@@ -554,8 +605,8 @@ public class CraftBlock implements Block {
         world.captureTreeGeneration = false;
 
         if (world.capturedBlockStates.size() > 0) {
-            TreeType treeType = SaplingBlock.treeType;
-            SaplingBlock.treeType = null;
+            TreeType treeType = SaplingBlock.treeTypeRT.get(); // SparklyPaper - parallel world ticking
+            SaplingBlock.treeTypeRT.set(null); // SparklyPaper - parallel world ticking
             List<BlockState> blocks = new ArrayList<>(world.capturedBlockStates.values());
             world.capturedBlockStates.clear();
             StructureGrowEvent structureEvent = null;
@@ -644,6 +695,11 @@ public class CraftBlock implements Block {
 
     @Override
     public RayTraceResult rayTrace(Location start, Vector direction, double maxDistance, FluidCollisionMode fluidCollisionMode) {
+        // SparklyPaper start - parallel world ticking
+        if (world instanceof ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, position, "Cannot read world asynchronously");
+        }
+        // SparklyPaper end - parallel world ticking
         Preconditions.checkArgument(start != null, "Location start cannot be null");
         Preconditions.checkArgument(this.getWorld().equals(start.getWorld()), "Location start cannot be a different world");
         start.checkFinite();
@@ -685,6 +741,11 @@ public class CraftBlock implements Block {
 
     @Override
     public boolean canPlace(BlockData data) {
+        // SparklyPaper start - parallel world ticking
+        if (world instanceof ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, position, "Cannot read world asynchronously");
+        }
+        // SparklyPaper end - parallel world ticking
         Preconditions.checkArgument(data != null, "BlockData cannot be null");
         net.minecraft.world.level.block.state.BlockState iblockdata = ((CraftBlockData) data).getState();
         net.minecraft.world.level.Level world = this.world.getMinecraftWorld();
@@ -719,6 +780,11 @@ public class CraftBlock implements Block {
 
     @Override
     public void tick() {
+        // SparklyPaper start - parallel world ticking
+        if (world instanceof ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, position, "Cannot modify world asynchronously");
+        }
+        // SparklyPaper end - parallel world ticking
         final ServerLevel level = this.world.getMinecraftWorld();
         this.getNMS().tick(level, this.position, level.random);
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java
index 04ae258a2f8e98421340d29d5cceedec045171b7..6a96ddb7097f7534ccf951f80de39f019b856b6a 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java
@@ -25,7 +25,7 @@ public abstract class CraftBlockEntityState<T extends BlockEntity> extends Craft
     private final T tileEntity;
     private final T snapshot;
     public boolean snapshotDisabled; // Paper
-    public static boolean DISABLE_SNAPSHOT = false; // Paper
+    public static ThreadLocal<Boolean> DISABLE_SNAPSHOT = ThreadLocal.withInitial(() -> Boolean.FALSE); // SparklyPaper - parallel world ticking
 
     public CraftBlockEntityState(World world, T tileEntity) {
         super(world, tileEntity.getBlockPos(), tileEntity.getBlockState());
@@ -34,8 +34,8 @@ public abstract class CraftBlockEntityState<T extends BlockEntity> extends Craft
 
         try { // Paper - Show blockstate location if we failed to read it
         // Paper start
-        this.snapshotDisabled = DISABLE_SNAPSHOT;
-        if (DISABLE_SNAPSHOT) {
+            this.snapshotDisabled = DISABLE_SNAPSHOT.get(); // SparklyPaper - parallel world ticking
+            if (DISABLE_SNAPSHOT.get()) { // SparklyPaper - parallel world ticking
             this.snapshot = this.tileEntity;
         } else {
             this.snapshot = this.createSnapshot(tileEntity);
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
index fa63a6cfcfcc4eee4503a82d85333c139c8c8b2b..9856860ee2987738bbcad5d752670e30f569ba74 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
@@ -215,6 +215,12 @@ public class CraftBlockState implements BlockState {
         LevelAccessor access = this.getWorldHandle();
         CraftBlock block = this.getBlock();
 
+        // SparklyPaper start - parallel world ticking
+        if (access instanceof net.minecraft.server.level.ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, position, "Cannot modify world asynchronously");
+        }
+        // SparklyPaper end - parallel world ticking
+
         if (block.getType() != this.getType()) {
             if (!force) {
                 return false;
@@ -350,6 +356,7 @@ public class CraftBlockState implements BlockState {
 
     @Override
     public java.util.Collection<org.bukkit.inventory.ItemStack> getDrops(org.bukkit.inventory.ItemStack item, org.bukkit.entity.Entity entity) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(world.getHandle(), position, "Cannot modify world asynchronously"); // SparklyPaper - parallel world ticking
         this.requirePlaced();
         net.minecraft.world.item.ItemStack nms = org.bukkit.craftbukkit.inventory.CraftItemStack.asNMSCopy(item);
 
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockStates.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockStates.java
index b7ff7af2513204b151340538d50a65c850bdb75f..45f9b2594e449926d7f00f64bf12fef2ea0a1393 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockStates.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockStates.java
@@ -247,8 +247,8 @@ public final class CraftBlockStates {
         net.minecraft.world.level.block.state.BlockState blockData = craftBlock.getNMS();
         BlockEntity tileEntity = craftBlock.getHandle().getBlockEntity(blockPosition);
         // Paper start - block state snapshots
-        boolean prev = CraftBlockEntityState.DISABLE_SNAPSHOT;
-        CraftBlockEntityState.DISABLE_SNAPSHOT = !useSnapshot;
+        boolean prev = CraftBlockEntityState.DISABLE_SNAPSHOT.get(); // SparklyPaper - parallel world ticking
+        CraftBlockEntityState.DISABLE_SNAPSHOT.set(!useSnapshot); // SparklyPaper - parallel world ticking
         try {
         // Paper end
         CraftBlockState blockState = CraftBlockStates.getBlockState(world, blockPosition, blockData, tileEntity);
@@ -256,7 +256,7 @@ public final class CraftBlockStates {
         return blockState;
         // Paper start
         } finally {
-            CraftBlockEntityState.DISABLE_SNAPSHOT = prev;
+            CraftBlockEntityState.DISABLE_SNAPSHOT.set(prev); // SparklyPaper - parallel world ticking
         }
         // Paper end
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
index 858c6c860d9b8aaa1d3f9f77a9e410726239d7cc..5e850b66a28fc9ba7fd953d385551cc2c3fb8c71 100644
--- a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
@@ -962,7 +962,7 @@ public class CraftEventFactory {
         return CraftEventFactory.handleBlockSpreadEvent(world, source, target, block, 2);
     }
 
-    public static BlockPos sourceBlockOverride = null; // SPIGOT-7068: Add source block override, not the most elegant way but better than passing down a BlockPosition up to five methods deep.
+    public static final ThreadLocal<BlockPos> sourceBlockOverrideRT = new ThreadLocal<>(); // SPIGOT-7068: Add source block override, not the most elegant way but better than passing down a BlockPosition up to five methods deep. // SparklyPaper - parallel world ticking (this is from Folia, fixes concurrency bugs with sculk catalysts)
 
     public static boolean handleBlockSpreadEvent(LevelAccessor world, BlockPos source, BlockPos target, net.minecraft.world.level.block.state.BlockState block, int flag) {
         // Suppress during worldgen
@@ -974,7 +974,7 @@ public class CraftEventFactory {
         CraftBlockState state = CraftBlockStates.getBlockState(world, target, flag);
         state.setData(block);
 
-        BlockSpreadEvent event = new BlockSpreadEvent(state.getBlock(), CraftBlock.at(world, CraftEventFactory.sourceBlockOverride != null ? CraftEventFactory.sourceBlockOverride : source), state);
+        BlockSpreadEvent event = new BlockSpreadEvent(state.getBlock(), CraftBlock.at(world, CraftEventFactory.sourceBlockOverrideRT.get() != null ? CraftEventFactory.sourceBlockOverrideRT.get() : source), state); // SparklyPaper - parallel world ticking
         Bukkit.getPluginManager().callEvent(event);
 
         if (!event.isCancelled()) {
@@ -2235,7 +2235,7 @@ public class CraftEventFactory {
         CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemStack.copyWithCount(1));
 
         org.bukkit.event.block.BlockDispenseEvent event = new org.bukkit.event.block.BlockDispenseEvent(bukkitBlock, craftItem.clone(), CraftVector.toBukkit(to));
-        if (!net.minecraft.world.level.block.DispenserBlock.eventFired) {
+        if (!net.minecraft.world.level.block.DispenserBlock.eventFired.get()) { // SparklyPaper - parallel world ticking
             if (!event.callEvent()) {
                 return itemStack;
             }
diff --git a/src/main/kotlin/net/sparklypower/sparklypaper/ServerLevelTickExecutorThreadFactory.kt b/src/main/kotlin/net/sparklypower/sparklypaper/ServerLevelTickExecutorThreadFactory.kt
new file mode 100644
index 0000000000000000000000000000000000000000..010a971098eb42e72a8edb2f3b6826f0fa6d17e5
--- /dev/null
+++ b/src/main/kotlin/net/sparklypower/sparklypaper/ServerLevelTickExecutorThreadFactory.kt
@@ -0,0 +1,21 @@
+package net.sparklypower.sparklypaper
+
+import ca.spottedleaf.moonrise.common.util.TickThread
+import java.util.concurrent.ThreadFactory
+import java.util.concurrent.atomic.AtomicInteger
+
+class ServerLevelTickExecutorThreadFactory(private val worldName: String) : ThreadFactory {
+    override fun newThread(p0: Runnable): Thread {
+        val tickThread = TickThread.ServerLevelTickThread(p0, "serverlevel-tick-worker [$worldName]")
+
+        if (tickThread.isDaemon) {
+            tickThread.isDaemon = false
+        }
+
+        if (tickThread.priority != 5) {
+            tickThread.priority = 5
+        }
+
+        return tickThread
+    }
+}
\ No newline at end of file
diff --git a/src/main/kotlin/net/sparklypower/sparklypaper/configs/SparklyPaperConfig.kt b/src/main/kotlin/net/sparklypower/sparklypaper/configs/SparklyPaperConfig.kt
new file mode 100644
index 0000000000000000000000000000000000000000..07adb1e70981cf9c5518984ca2c8c50ff6f0ef4d
--- /dev/null
+++ b/src/main/kotlin/net/sparklypower/sparklypaper/configs/SparklyPaperConfig.kt
@@ -0,0 +1,15 @@
+package net.sparklypower.sparklypaper.configs
+
+import kotlinx.serialization.SerialName
+import kotlinx.serialization.Serializable
+
+@Serializable
+class SparklyPaperConfig(
+    @SerialName("parallel-world-ticking")
+    val parallelWorldTicking:ParallelWorldTicking
+) {
+    @Serializable
+    class ParallelWorldTicking(
+        val threads:Int
+    )
+}
\ No newline at end of file
diff --git a/src/main/kotlin/net/sparklypower/sparklypaper/configs/SparklyPaperConfigUtils.kt b/src/main/kotlin/net/sparklypower/sparklypaper/configs/SparklyPaperConfigUtils.kt
new file mode 100644
index 0000000000000000000000000000000000000000..832e6d5ff24e712e25a649666e72e4f3f3505e54
--- /dev/null
+++ b/src/main/kotlin/net/sparklypower/sparklypaper/configs/SparklyPaperConfigUtils.kt
@@ -0,0 +1,48 @@
+package net.sparklypower.sparklypaper.configs
+
+import com.charleskorn.kaml.Yaml
+import com.charleskorn.kaml.YamlConfiguration
+import com.google.common.base.Throwables
+import kotlinx.serialization.SerializationException
+import kotlinx.serialization.decodeFromString
+import kotlinx.serialization.encodeToString
+import org.bukkit.Bukkit
+import java.io.File
+import java.util.logging.Level
+
+object SparklyPaperConfigUtils {
+    val yaml = Yaml(
+        configuration = YamlConfiguration(
+            strictMode = false
+        )
+    )
+    lateinit var config: SparklyPaperConfig
+    val logContainerCreationStacktraces = java.lang.Boolean.getBoolean("sparklypaper.logContainerCreationStacktraces")
+
+    fun init(configFile: File) {
+        // Write default config if the file doesn't exist
+        if (!configFile.exists()) {
+            configFile.writeText(
+                yaml.encodeToString(
+                    SparklyPaperConfig(
+                        SparklyPaperConfig.ParallelWorldTicking(
+                            threads = 8
+                        )
+                    )
+                )
+            )
+        }
+
+        val loadedConfig = try {
+            yaml.decodeFromString<SparklyPaperConfig>(configFile.readText())
+        } catch (e: SerializationException) {
+            Bukkit.getLogger()
+                .log(Level.SEVERE, "Could not load sparklypaper.yml, please correct your syntax errors", e)
+            throw Throwables.propagate(e)
+        }
+        // Rewrite the config file to remove old fields and stuff
+        // TODO: Maybe handle this in another way? This feels kinda bad
+        configFile.writeText(yaml.encodeToString(loadedConfig))
+        config = loadedConfig
+    }
+}
\ No newline at end of file
